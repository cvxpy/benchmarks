{
    "cvar_benchmark.CVaRBenchmark.time_compile_problem": {
        "code": "class CVaRBenchmark:\n    def time_compile_problem(self):\n        self.problem.get_problem_data(solver=cp.SCS)\n\n    def setup(self):\n        # Replaced real data with random values\n        np.random.seed(0)\n        price_scenarios = np.random.randn(131072, 192)\n        forward_price_scenarios = np.random.randn(131072, 192)\n        asset_energy_limits = np.random.randn(192, 2)\n        bid_curve_prices = np.random.randn(192, 3)\n        cvar_prob = 0.95\n        cvar_kappa = 2.0\n    \n        num_scenarios, num_assets = price_scenarios.shape\n        num_energy_segments = bid_curve_prices.shape[1] + 1\n    \n        price_segments = np.sum(\n            forward_price_scenarios[:, :, None] > bid_curve_prices[None], axis=2\n        )\n        price_segments_flat = (\n            price_segments + np.arange(num_assets) * num_energy_segments\n        ).reshape(-1)\n        price_segments_sp = sp.coo_matrix(\n            (\n                np.ones(num_scenarios * num_assets),\n                (np.arange(num_scenarios * num_assets), price_segments_flat),\n            ),\n            shape=(num_scenarios * num_assets, num_assets * num_energy_segments),\n        )\n    \n        prices_flat = (price_scenarios - forward_price_scenarios).reshape(-1)\n        scenario_sum = sp.coo_matrix(\n            (\n                np.ones(num_scenarios * num_assets),\n                (\n                    np.repeat(np.arange(num_scenarios), num_assets),\n                    np.arange(num_scenarios * num_assets),\n                ),\n            )\n        )\n    \n        A = np.asarray((scenario_sum @ sp.diags(prices_flat) @ price_segments_sp).todense())\n        c = np.mean(A, axis=0)\n        gamma = 1.0 / (1.0 - cvar_prob) / num_scenarios\n        kappa = cvar_kappa\n        x_min = np.tile(asset_energy_limits[:, 0:1], (1, num_energy_segments)).reshape(-1)\n        x_max = np.tile(asset_energy_limits[:, 1:2], (1, num_energy_segments)).reshape(-1)\n    \n        alpha = cp.Variable()\n        x = cp.Variable(num_assets * num_energy_segments)\n    \n        problem = cp.Problem(\n            cp.Minimize(c.T @ x),\n            [\n                alpha + gamma * cp.sum(cp.pos(A @ x - alpha)) <= kappa,\n                x >= x_min,\n                x <= x_max,\n            ],\n        )\n    \n        self.problem = problem",
        "min_run_count": 2,
        "name": "cvar_benchmark.CVaRBenchmark.time_compile_problem",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 999,
        "type": "time",
        "unit": "seconds",
        "version": "2a130e57c07794b9a40b3e5a9a60e571c4fd23d7bc4db3d214200c409f06decc",
        "warmup_time": -1
    },
    "qp_1611_benchmark.QP1611Benchmark.time_compile_problem": {
        "code": "class QP1611Benchmark:\n    def time_compile_problem(self):\n        self.problem.get_problem_data(solver=cp.ECOS_BB)\n\n    def setup(self):\n        with open(QP1611Benchmark.filename, \"rb\") as f:\n            problem = pickle.load(f)\n        self.problem = problem",
        "min_run_count": 2,
        "name": "qp_1611_benchmark.QP1611Benchmark.time_compile_problem",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 999,
        "type": "time",
        "unit": "seconds",
        "version": "4f1e2751391e8545c90058b89a009be9a8748d009ad99b6f8a11222d314838cd",
        "warmup_time": -1
    },
    "sdp_segfault_1132_benchmark.SDPSegfault1132Benchmark.time_compile_problem": {
        "code": "class SDPSegfault1132Benchmark:\n    def time_compile_problem(self):\n        self.problem.get_problem_data(solver=cp.SCS)\n\n    def setup(self):\n        n = 100\n        alpha = 1\n        np.random.seed(0)\n        points = np.random.rand(5, n)\n        xtx = points.T @ points\n        xtxd = np.diag(xtx)\n        e = np.ones((n,))\n        D = np.outer(e, xtxd) - 2 * xtx + np.outer(xtxd, e)\n        # Construct W\n        W = np.ones((n, n))\n    \n        # Define V and e\n        n = D.shape[0]\n        x = -1 / (n + np.sqrt(n))\n        y = -1 / np.sqrt(n)\n        V = np.ones((n, n - 1))\n        V[0, :] *= y\n        V[1:, :] *= x\n        V[1:, :] += np.eye(n - 1)\n        e = np.ones((n, 1))\n    \n        # Solve optimization problem\n        G = cp.Variable((n - 1, n - 1), PSD=True)\n        A = cp.kron(e, cp.reshape(cp.diag(V @ G @ V.T), (1, n)))\n        B = cp.kron(e.T, cp.reshape(cp.diag(V @ G @ V.T), (n, 1)))\n        C = alpha * cp.norm(cp.multiply(W, A + B - 2 * V @ G @ V.T - D), p=\"fro\")\n        objective = cp.Maximize(cp.trace(G) - C)\n        problem = cp.Problem(objective, [])\n        self.problem = problem",
        "min_run_count": 2,
        "name": "sdp_segfault_1132_benchmark.SDPSegfault1132Benchmark.time_compile_problem",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 999,
        "type": "time",
        "unit": "seconds",
        "version": "ed808360d3230f364014822f855b979ad49e444e8bdeb093f06f2452c0c8deb5",
        "warmup_time": -1
    },
    "simple_LP_benchmarks.SimpleFullyParametrizedLPBenchmark.time_compile_problem": {
        "code": "class SimpleFullyParametrizedLPBenchmark:\n    def time_compile_problem(self):\n        self.problem.get_problem_data(solver=cp.SCS)\n\n    def setup(self):\n        n = int(1e4)\n        p = cp.Parameter(n)\n        x = cp.Variable(n)\n        objective = cp.Minimize(p @ x)\n        constraints = [0 <= x, x <= 1]\n        problem = cp.Problem(objective, constraints)\n        self.problem = problem",
        "min_run_count": 2,
        "name": "simple_LP_benchmarks.SimpleFullyParametrizedLPBenchmark.time_compile_problem",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "107c2224d8c77ed7a8e5e3a7ae3545dc2357739b7a7f37f02d5d8372fa10db09",
        "warmup_time": -1
    },
    "simple_LP_benchmarks.SimpleLPBenchmark.time_compile_problem": {
        "code": "class SimpleLPBenchmark:\n    def time_compile_problem(self):\n        self.problem.get_problem_data(solver=cp.SCS)\n\n    def setup(self):\n        n = int(1e7)\n        c = np.arange(n)\n        x = cp.Variable(n)\n        objective = cp.Minimize(c @ x)\n        constraints = [0 <= x, x <= 1]\n        problem = cp.Problem(objective, constraints)\n        self.problem = problem",
        "min_run_count": 2,
        "name": "simple_LP_benchmarks.SimpleLPBenchmark.time_compile_problem",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "b81438c7919e9cb9394ca22fad039deba1325311fe54c0ae980452b93f34fe01",
        "warmup_time": -1
    },
    "simple_LP_benchmarks.SimpleScalarParametrizedLPBenchmark.time_compile_problem": {
        "code": "class SimpleScalarParametrizedLPBenchmark:\n    def time_compile_problem(self):\n        self.problem.get_problem_data(solver=cp.SCS)\n\n    def setup(self):\n        n = int(1e6)\n        p = cp.Parameter()\n        c = np.arange(n)\n        x = cp.Variable(n)\n        objective = cp.Minimize((p * c) @ x)\n        constraints = [0 <= x, x <= 1]\n        problem = cp.Problem(objective, constraints)\n        self.problem = problem",
        "min_run_count": 2,
        "name": "simple_LP_benchmarks.SimpleScalarParametrizedLPBenchmark.time_compile_problem",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "643deb6bc63211d7d322ac7ec9fe22c254ac6122afa51d53009157dbec777013",
        "warmup_time": -1
    },
    "version": 2
}