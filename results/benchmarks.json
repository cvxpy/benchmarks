{
    "finance.CVaRBenchmark.time_compile_problem": {
        "code": "class CVaRBenchmark:\n    def time_compile_problem(self):\n        self.problem.get_problem_data(solver=cp.SCS)\n\n    def setup(self):\n        # Replaced real data with random values\n        np.random.seed(0)\n        price_scenarios = np.random.randn(131072, 192)\n        forward_price_scenarios = np.random.randn(131072, 192)\n        asset_energy_limits = np.random.randn(192, 2)\n        bid_curve_prices = np.random.randn(192, 3)\n        cvar_prob = 0.95\n        cvar_kappa = 2.0\n    \n        num_scenarios, num_assets = price_scenarios.shape\n        num_energy_segments = bid_curve_prices.shape[1] + 1\n    \n        price_segments = np.sum(\n            forward_price_scenarios[:, :, None] > bid_curve_prices[None], axis=2\n        )\n        price_segments_flat = (\n            price_segments + np.arange(num_assets) * num_energy_segments\n        ).reshape(-1)\n        price_segments_sp = sp.coo_matrix(\n            (\n                np.ones(num_scenarios * num_assets),\n                (np.arange(num_scenarios * num_assets), price_segments_flat),\n            ),\n            shape=(num_scenarios * num_assets, num_assets * num_energy_segments),\n        )\n    \n        prices_flat = (price_scenarios - forward_price_scenarios).reshape(-1)\n        scenario_sum = sp.coo_matrix(\n            (\n                np.ones(num_scenarios * num_assets),\n                (\n                    np.repeat(np.arange(num_scenarios), num_assets),\n                    np.arange(num_scenarios * num_assets),\n                ),\n            )\n        )\n    \n        A = np.asarray((scenario_sum @ sp.diags(prices_flat) @ price_segments_sp).todense())\n        c = np.mean(A, axis=0)\n        gamma = 1.0 / (1.0 - cvar_prob) / num_scenarios\n        kappa = cvar_kappa\n        x_min = np.tile(asset_energy_limits[:, 0:1], (1, num_energy_segments)).reshape(-1)\n        x_max = np.tile(asset_energy_limits[:, 1:2], (1, num_energy_segments)).reshape(-1)\n    \n        alpha = cp.Variable()\n        x = cp.Variable(num_assets * num_energy_segments)\n    \n        problem = cp.Problem(\n            cp.Minimize(c.T @ x),\n            [\n                alpha + gamma * cp.sum(cp.pos(A @ x - alpha)) <= kappa,\n                x >= x_min,\n                x <= x_max,\n            ],\n        )\n    \n        self.problem = problem",
        "min_run_count": 2,
        "name": "finance.CVaRBenchmark.time_compile_problem",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 999,
        "type": "time",
        "unit": "seconds",
        "version": "2a130e57c07794b9a40b3e5a9a60e571c4fd23d7bc4db3d214200c409f06decc",
        "warmup_time": -1
    },
    "finance.FactorCovarianceModel.time_compile_problem": {
        "code": "class FactorCovarianceModel:\n    def time_compile_problem(self):\n        self.Lmax.value = 2\n        self.gamma.value = 0.1\n        self.problem.get_problem_data(solver=cp.SCS)\n\n    def setup(self):\n        n = 14500\n        m = 250\n        np.random.seed(1)\n        mu = np.abs(np.random.randn(n, 1))\n        Sigma_tilde = np.random.randn(m, m)\n        Sigma_tilde = Sigma_tilde.T.dot(Sigma_tilde)\n        D = sp.diags(np.random.uniform(0, 0.9, size=n))\n        F = np.random.randn(n, m)\n    \n        # Factor model portfolio optimization.\n        w = cp.Variable(n)\n        f = cp.Variable(m)\n        self.gamma = cp.Parameter(nonneg=True)\n        self.Lmax = cp.Parameter()\n        ret = mu.T @ w\n        risk = cp.quad_form(f, Sigma_tilde, assume_PSD=True) + cp.sum_squares(np.sqrt(D) @ w)\n        objective = cp.Maximize(ret - self.gamma * risk)\n        constraints = [cp.sum(w) == 1, f == F.T @ w, cp.norm(w, 1) <= self.Lmax]\n        problem = cp.Problem(objective, constraints)\n        self.problem = problem",
        "min_run_count": 2,
        "name": "finance.FactorCovarianceModel.time_compile_problem",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "05132bd6e29e6e5d0fb509a69889005e56a9f1cce65b2369b4881a41e0a2ad6d",
        "warmup_time": -1
    },
    "gini_portfolio.Cajas.time_compile_problem": {
        "code": "class Cajas:\n    def time_compile_problem(self):\n        self.problem.get_problem_data(solver=cp.SCS)\n\n    def setup(self):\n        rs = np.random.RandomState(123)\n        N = 50\n        T = 350\n        cov = rs.rand(N,N) * 1.5 - 0.5\n        cov = cov @ cov.T/1000 + np.diag(rs.rand(N) * 0.7 + 0.3)/1000\n        mean = np.zeros(N) + 1/1000\n        returns = st.multivariate_normal.rvs(mean=mean, cov=cov, size=T, random_state=rs)\n    \n        w = cp.Variable((N,1))\n        constraints = []\n        a = cp.Variable((T,1))\n        b = cp.Variable((T,1))\n        y = cp.Variable((T,1))\n        owa_w = []\n        for i in range(1,T+1):\n            owa_w.append(2*i - 1 - T)\n        owa_w = np.array(owa_w) / (T * (T-1))\n        constraints = [returns @ w == y,\n                       w >= 0,\n                       cp.sum(w) == 1]\n        for i in range(T):\n            constraints += [a[i] + b >= cp.multiply(owa_w[i], y)]\n        risk = cp.sum(a + b)\n        objective = cp.Minimize(risk * 1000)\n        problem = cp.Problem(objective, constraints)\n        self.problem = problem",
        "min_run_count": 2,
        "name": "gini_portfolio.Cajas.time_compile_problem",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "f73882f5ed1e93da259896f54d6c7fa2f2684002ff47c9b4354e1a607c04eefd",
        "warmup_time": -1
    },
    "gini_portfolio.Murray.time_compile_problem": {
        "code": "class Murray:\n    def time_compile_problem(self):\n        self.problem.get_problem_data(solver=cp.SCS)\n\n    def setup(self):\n        rs = np.random.RandomState(123)\n        N = 50\n        T = 350\n        cov = rs.rand(N, N) * 1.5 - 0.5\n        cov = cov @ cov.T/1000 + np.diag(rs.rand(N) * 0.7 + 0.3)/1000\n        mean = np.zeros(N) + 1/1000\n        returns = st.multivariate_normal.rvs(mean=mean, cov=cov, size=T, random_state=rs)\n    \n        d = cp.Variable((int(T * (T - 1) / 2), 1))\n        w = cp.Variable((N, 1))\n        constraints = []\n        ret_w = cp.Variable((T, 1))\n        constraints.append(ret_w == returns @ w)\n        mat = np.zeros((d.shape[0], T))\n        \"\"\"\n        We need to create a vector that has the following entries:\n            ret_w[i] - ret_w[j]\n        for j in range(T), for i in range(j+1, T).\n        We do this by building a numpy array of mostly 0's and 1's.\n        (It would be better to use SciPy sparse matrix objects.)\n        \"\"\"\n        ell = 0\n        for j in range(T):\n            for i in range(j + 1, T):\n                # write to mat so that (mat @ ret_w)[ell] == var_i - var_j\n                mat[ell, i] = 1\n                mat[ell, j] = -1\n                ell += 1\n        all_pairs_ret_diff = mat @ ret_w\n        constraints += [d >= all_pairs_ret_diff,\n                        d >= -all_pairs_ret_diff,\n                        w >= 0,\n                        cp.sum(w) == 1]\n        risk = cp.sum(d) / ((T - 1) * T)\n        objective = cp.Minimize(risk * 1000)\n        problem = cp.Problem(objective, constraints)\n        self.problem = problem",
        "min_run_count": 2,
        "name": "gini_portfolio.Murray.time_compile_problem",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "8cfb1206dbc330b898207e296b54520e413bbbf8d0e6d24dbc616a5663846716",
        "warmup_time": -1
    },
    "gini_portfolio.Yitzhaki.time_compile_problem": {
        "code": "class Yitzhaki:\n    def time_compile_problem(self):\n        self.problem.get_problem_data(solver=cp.SCS)\n\n    def setup(self):\n        rs = np.random.RandomState(123)\n        N = 50\n        T = 150\n        cov = rs.rand(N, N) * 1.5 - 0.5\n        cov = cov @ cov.T/1000 + np.diag(rs.rand(N) * 0.7 + 0.3)/1000\n        mean = np.zeros(N) + 1/1000\n        returns = st.multivariate_normal.rvs(mean=mean, cov=cov, size=T, random_state=rs)\n        assets = ['Asset ' + str(i) for i in range(1, N + 1)]\n        D = np.array([]).reshape(0, len(assets))\n        for j in range(0, returns.shape[0]-1):\n            D = np.concatenate((D, returns[j+1:] - returns[j, :]), axis=0)\n    \n        d = cp.Variable((int(T * (T - 1) / 2), 1))\n        w = cp.Variable((N, 1))\n        constraints = []\n        all_pairs_ret_diff = D @ w\n        constraints += [d >= all_pairs_ret_diff,\n                        d >= -all_pairs_ret_diff,\n                        w >= 0,\n                        cp.sum(w) == 1]\n        risk = cp.sum(d) / ((T - 1) * T)\n        objective = cp.Minimize(risk * 1000)\n        problem = cp.Problem(objective, constraints)\n        self.problem = problem",
        "min_run_count": 2,
        "name": "gini_portfolio.Yitzhaki.time_compile_problem",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "7cc5581008142caaccffd2307bc2f406b6984042d224f9c61979bc06835538c1",
        "warmup_time": -1
    },
    "high_dim_convex_plasticity.ConvexPlasticity.time_compile_problem": {
        "code": "class ConvexPlasticity:\n    def time_compile_problem(self):\n        self.problem.get_problem_data(solver=cp.SCS)\n\n    def setup(self):\n        E_dim = 70e3  # [Pa]\n        E = 70e3 / E_dim  # [-] Young's modulus\n        nu = 0.3  # [-] Poisson's ratio\n        sig0 = 250 / E_dim  # [-] yield strength\n        Et = E / 100.0  # [-] tangent modulus\n        H = E * Et / (E - Et)  # [-] hardening modulus\n    \n        l, m = E * nu / (1 + nu) / (1 - 2 * nu), E / 2 / (1 + nu)  # noqa: E741\n    \n        # Elasticity stiffness matrix\n        C = np.array(\n            [\n                [l + 2 * m, l, l, 0],\n                [l, l + 2 * m, l, 0],\n                [l, l, l + 2 * m, 0],\n                [0, 0, 0, 2 * m],\n            ]\n        )\n        S = np.linalg.inv(C)\n    \n        def criterion(sig: cp.Variable, p: cp.Variable):\n            N = p.size\n            dev = np.array(\n                [\n                    [2 / 3.0, -1 / 3.0, -1 / 3.0, 0],\n                    [-1 / 3.0, 2 / 3.0, -1 / 3.0, 0],\n                    [-1 / 3.0, -1 / 3.0, 2 / 3.0, 0],\n                    [0, 0, 0, 1.0],\n                ]\n            )\n    \n            sig0_vec = np.repeat(sig0, N)\n            s = dev @ sig\n            return [np.sqrt(3 / 2) * cp.norm(s, axis=0) <= sig0_vec + p * H]\n    \n        particular_deps = np.array(\n            [7.24276667e-04, -3.41842340e-04, 0.00000000e00, -2.65071262e-05]\n        )\n        deps_dummy = np.full((4000, 4), particular_deps)\n    \n        N = 500\n        deps_local_values = deps_dummy[:N]\n    \n        deps = cp.Parameter((4, N), name=\"deps\")\n        sig_old = cp.Parameter((4, N), name=\"sig_old\")\n        sig_elas = sig_old + C @ deps\n        sig = cp.Variable((4, N), name=\"sig\")\n        p_old = cp.Parameter((N,), nonneg=True, name=\"p_old\")\n        p = cp.Variable((N,), nonneg=True, name=\"p\")\n    \n        sig_old.value = np.zeros((4, N))\n        deps.value = np.zeros((4, N))\n        p_old.value = np.zeros((N,))\n        deps.value = deps_local_values.T\n    \n        delta_sig = sig - sig_elas\n        D = H * np.eye(N)\n        S_sparsed = block_diag([S for _ in range(N)])\n        delta_sig_vector = cp.reshape(delta_sig, (N * 4))\n    \n        elastic_energy = cp.quad_form(delta_sig_vector, S_sparsed, assume_PSD=True)\n        target_expression = 0.5 * elastic_energy + 0.5 * cp.quad_form(p - p_old, D)\n        constraints = criterion(sig, p)\n    \n        problem = cp.Problem(cp.Minimize(target_expression), constraints)\n    \n        self.problem = problem",
        "min_run_count": 2,
        "name": "high_dim_convex_plasticity.ConvexPlasticity.time_compile_problem",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "f324901397b434a5e2523f3afcf900cf3aaee0691640a60489228589016e2024",
        "warmup_time": -1
    },
    "huber_regression.HuberRegression.time_compile_problem": {
        "code": "class HuberRegression:\n    def time_compile_problem(self):\n        self.problem.get_problem_data(solver=cp.SCS)\n\n    def setup(self):\n        np.random.seed(1)\n        n = 3000\n        p = 0.12\n        SAMPLES = int(1.5 * n)\n        beta_true = 5 * np.random.normal(size=(n, 1))\n        X = np.random.randn(n, SAMPLES)\n        v = np.random.normal(size=(SAMPLES, 1))\n    \n        # Generate the sign changes.\n        factor = 2 * np.random.binomial(1, 1 - p, size=(SAMPLES, 1)) - 1\n        Y = factor * X.T.dot(beta_true) + v\n        beta = cp.Variable((n, 1))\n        # Solve a huber regression problem\n        cost = cp.sum(cp.huber(X.T @ beta - Y, 1))\n        objective = cp.Minimize(cost)\n        problem = cp.Problem(objective)\n        self.problem = problem",
        "min_run_count": 2,
        "name": "huber_regression.HuberRegression.time_compile_problem",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "370ff6507bcc626b80bd3ca3731e4b1df2171a5b7510fb7e43a09572a8b2c71e",
        "warmup_time": -1
    },
    "matrix_stuffing.ConeMatrixStuffingBench.time_compile_problem": {
        "code": "class ConeMatrixStuffingBench:\n    def time_compile_problem(self):\n        cms = ConeMatrixStuffing()\n        cms.apply(self.problem)\n\n    def setup(self):\n        m = 2000\n        n = 2000\n        A = np.random.randn(m, n)\n        C = np.random.rand(m // 2)\n        b = np.random.randn(m)\n    \n        x = cp.Variable(n)\n        cost = cp.sum(A @ x)\n    \n        constraints = [C[i] * x[i] <= b[i] for i in range(m // 2)]\n        constraints.extend([C[i] * x[m // 2 + i] == b[m // 2 + i] for i in range(m // 2)])\n    \n        problem = cp.Problem(cp.Minimize(cost), constraints)\n        self.problem = problem",
        "min_run_count": 2,
        "name": "matrix_stuffing.ConeMatrixStuffingBench.time_compile_problem",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "d125bf0d94750542fdd88d64036c1b7330ce9bca4303bab8471c4a1e598d38c8",
        "warmup_time": -1
    },
    "matrix_stuffing.ParamConeMatrixStuffing.time_compile_problem": {
        "code": "class ParamConeMatrixStuffing:\n    def time_compile_problem(self):\n        cms = ConeMatrixStuffing()\n        cms.apply(self.problem)\n\n    def setup(self):\n        m = 200\n        n = 200\n        A = cp.Parameter((m, n))\n        C = cp.Parameter(m // 2)\n        b = cp.Parameter(m)\n        A.value = np.random.randn(m, n)\n        C.value = np.random.rand(m // 2)\n        b.value = np.random.randn(m)\n    \n        x = cp.Variable(n)\n        cost = cp.sum(A @ x)\n    \n        constraints = [C[i] * x[i] <= b[i] for i in range(m // 2)]\n        constraints.extend([C[i] * x[m // 2 + i] == b[m // 2 + i] for i in range(m // 2)])\n    \n        problem = cp.Problem(cp.Minimize(cost), constraints)\n        self.problem = problem",
        "min_run_count": 2,
        "name": "matrix_stuffing.ParamConeMatrixStuffing.time_compile_problem",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "56696934c045873dd9388d364c2cce6d29ae04d32455761d720571f0c7b0bd61",
        "warmup_time": -1
    },
    "matrix_stuffing.ParamSmallMatrixStuffing.time_compile_problem": {
        "code": "class ParamSmallMatrixStuffing:\n    def time_compile_problem(self):\n        cms = ConeMatrixStuffing()\n        cms.apply(self.problem)\n\n    def setup(self):\n        m = 100\n        n = 100\n        A = cp.Parameter((m, n))\n        C = cp.Parameter(m // 2)\n        b = cp.Parameter(m)\n        A.value = np.random.randn(m, n)\n        C.value = np.random.rand(m // 2)\n        b.value = np.random.randn(m)\n    \n        x = cp.Variable(n)\n        cost = cp.sum(A @ x)\n    \n        constraints = [C[i] * x[i] <= b[i] for i in range(m // 2)]\n        constraints.extend([C[i] * x[m // 2 + i] == b[m // 2 + i] for i in range(m // 2)])\n    \n        problem = cp.Problem(cp.Minimize(cost), constraints)\n        self.problem = problem",
        "min_run_count": 2,
        "name": "matrix_stuffing.ParamSmallMatrixStuffing.time_compile_problem",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "81b8fb141469c5aabb73461185550a9956d91a1ba85995911648101740f3d591",
        "warmup_time": -1
    },
    "matrix_stuffing.SmallMatrixStuffing.time_compile_problem": {
        "code": "class SmallMatrixStuffing:\n    def time_compile_problem(self):\n        cms = ConeMatrixStuffing()\n        cms.apply(self.problem)\n\n    def setup(self):\n        m = 200\n        n = 200\n        A = np.random.randn(m, n)\n        C = np.random.rand(m // 2)\n        b = np.random.randn(m)\n    \n        x = cp.Variable(n)\n        cost = cp.sum(A @ x)\n    \n        constraints = [C[i] * x[i] <= b[i] for i in range(m // 2)]\n        constraints.extend([C[i] * x[m // 2 + i] == b[m // 2 + i] for i in range(m // 2)])\n    \n        problem = cp.Problem(cp.Minimize(cost), constraints)\n        self.problem = problem",
        "min_run_count": 2,
        "name": "matrix_stuffing.SmallMatrixStuffing.time_compile_problem",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "ad3de554debe53fd9b8f4d8110f4b3534a4f1a6db334b2934d28c3a47c88b849",
        "warmup_time": -1
    },
    "optimal_advertising.OptimalAdvertising.time_compile_problem": {
        "code": "class OptimalAdvertising:\n    def time_compile_problem(self):\n        self.problem.get_problem_data(solver=cp.SCS)\n\n    def setup(self):\n        np.random.seed(1)\n        m = 250\n        n = 1000\n        SCALE = 10000\n        B = np.random.lognormal(mean=8, size=(m, 1)) + 10000\n        B = 1000 * np.round(B / 1000)\n    \n        P_ad = np.random.uniform(size=(m, 1))\n        P_time = np.random.uniform(size=(1, n))\n        P = P_ad.dot(P_time)\n    \n        T = np.sin(np.linspace(-2 * np.pi / 2, 2 * np.pi - 2 * np.pi / 2, n)) * SCALE\n        T += -np.min(T) + SCALE\n        c = np.random.uniform(size=(m,))\n        c *= 0.6 * T.sum() / c.sum()\n        c = 1000 * np.round(c / 1000)\n        R = np.array([np.random.lognormal(c.min() / c[i]) for i in range(m)])\n    \n        # Solve optimization problem\n        D = cp.Variable((m, n))\n        Si = [cp.minimum(R[i] * P[i, :] @ D[i, :].T, B[i]) for i in range(m)]\n        objective = cp.Maximize(cp.sum(Si))\n        constraints = [D >= 0, D.T @ np.ones(m) <= T, D @ np.ones(n) >= c]\n        problem = cp.Problem(objective, constraints)\n        self.problem = problem",
        "min_run_count": 2,
        "name": "optimal_advertising.OptimalAdvertising.time_compile_problem",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "c1a33d0f2763ff52fb848b520767be561f657e1ed9704dd7f263d252b8391fd5",
        "warmup_time": -1
    },
    "quantum_hilbert_matrix.QuantumHilbertMatrix.time_compile_problem": {
        "code": "class QuantumHilbertMatrix:\n    def time_compile_problem(self):\n        self.problem.get_problem_data(solver=cp.SCS)\n\n    def setup(self):\n        d = 2  # local hilbert space dimension\n        N = 3  # number of qubits\n        dim = d**N  # hilbert space dimension of full system\n    \n        I = sparse.identity(dim)  # sparse identity matrix  # noqa: E741\n    \n        rng = default_rng(0)\n        # sparse matrices with the same density as the ones in my problem\n        rhs = sparse.random(\n            m=dim**2, n=dim**2, density=0.05810546875, random_state=rng\n        )\n        A = sparse.random(\n            m=dim**2, n=dim**2, density=0.29058837890625, random_state=rng\n        )\n    \n        AxI = sparse.kron(\n            A, I\n        )  # doing this beforehand to decrease number of expressions in cvxpy cost function\n    \n        X = cp.Variable((dim**2, dim**2), PSD=True)  # PSD variable\n        lhs = cp.partial_trace(\n            cp.kron(I, cp.partial_transpose(X, dims=[dim, dim], axis=0)) @ AxI,\n            dims=[dim, dim, dim],\n            axis=1,\n        )\n        cost = cp.sum_squares(lhs - rhs)\n        problem = cp.Problem(cp.Minimize(cost))\n        self.problem = problem",
        "min_run_count": 2,
        "name": "quantum_hilbert_matrix.QuantumHilbertMatrix.time_compile_problem",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "97bae84afd5421f74a8aea822cc392e4cee9a0fe5ee8ef1e4640ed869ec19306",
        "warmup_time": -1
    },
    "sdp_segfault_1132_benchmark.SDPSegfault1132Benchmark.time_compile_problem": {
        "code": "class SDPSegfault1132Benchmark:\n    def time_compile_problem(self):\n        self.problem.get_problem_data(solver=cp.SCS)\n\n    def setup(self):\n        n = 100\n        alpha = 1\n        np.random.seed(0)\n        points = np.random.rand(5, n)\n        xtx = points.T @ points\n        xtxd = np.diag(xtx)\n        e = np.ones((n,))\n        D = np.outer(e, xtxd) - 2 * xtx + np.outer(xtxd, e)\n        # Construct W\n        W = np.ones((n, n))\n    \n        # Define V and e\n        n = D.shape[0]\n        x = -1 / (n + np.sqrt(n))\n        y = -1 / np.sqrt(n)\n        V = np.ones((n, n - 1))\n        V[0, :] *= y\n        V[1:, :] *= x\n        V[1:, :] += np.eye(n - 1)\n        e = np.ones((n, 1))\n    \n        # Solve optimization problem\n        G = cp.Variable((n - 1, n - 1), PSD=True)\n        A = cp.kron(e, cp.reshape(cp.diag(V @ G @ V.T), (1, n)))\n        B = cp.kron(e.T, cp.reshape(cp.diag(V @ G @ V.T), (n, 1)))\n        C = alpha * cp.norm(cp.multiply(W, A + B - 2 * V @ G @ V.T - D), p=\"fro\")\n        objective = cp.Maximize(cp.trace(G) - C)\n        problem = cp.Problem(objective, [])\n        self.problem = problem",
        "min_run_count": 2,
        "name": "sdp_segfault_1132_benchmark.SDPSegfault1132Benchmark.time_compile_problem",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 999,
        "type": "time",
        "unit": "seconds",
        "version": "ed808360d3230f364014822f855b979ad49e444e8bdeb093f06f2452c0c8deb5",
        "warmup_time": -1
    },
    "semidefinite_programming.SemidefiniteProgramming.time_compile_problem": {
        "code": "class SemidefiniteProgramming:\n    def time_compile_problem(self):\n        self.problem.get_problem_data(solver=cp.SCS)\n\n    def setup(self):\n        # Generate a random SDP.\n        n = 125\n        p = 75\n        np.random.seed(1)\n        C = np.random.randn(n, n)\n        A = []\n        b = []\n        for i in range(p):\n            A.append(np.random.randn(n, n))\n            b.append(np.random.randn())\n    \n        # Define and solve the CVXPY problem.\n        # Create a symmetric matrix variable.\n        X = cp.Variable((n, n), symmetric=True)\n        constraints = [X >> 0]\n        constraints += [cp.trace(A[i] @ X) == b[i] for i in range(p)]\n        objective = cp.Minimize(cp.trace(C @ X))\n        problem = cp.Problem(objective, constraints)\n        self.problem = problem",
        "min_run_count": 2,
        "name": "semidefinite_programming.SemidefiniteProgramming.time_compile_problem",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "b8f19042c318507db3a79f3dfda663b94bfe6f0af2b43bf818e5c7f75fce4c59",
        "warmup_time": -1
    },
    "simple_LP_benchmarks.SimpleFullyParametrizedLPBenchmark.time_compile_problem": {
        "code": "class SimpleFullyParametrizedLPBenchmark:\n    def time_compile_problem(self):\n        self.problem.get_problem_data(solver=cp.SCS)\n\n    def setup(self):\n        n = int(1e4)\n        p = cp.Parameter(n)\n        x = cp.Variable(n)\n        objective = cp.Minimize(p @ x)\n        constraints = [0 <= x, x <= 1]\n        problem = cp.Problem(objective, constraints)\n        self.problem = problem",
        "min_run_count": 2,
        "name": "simple_LP_benchmarks.SimpleFullyParametrizedLPBenchmark.time_compile_problem",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "107c2224d8c77ed7a8e5e3a7ae3545dc2357739b7a7f37f02d5d8372fa10db09",
        "warmup_time": -1
    },
    "simple_LP_benchmarks.SimpleLPBenchmark.time_compile_problem": {
        "code": "class SimpleLPBenchmark:\n    def time_compile_problem(self):\n        self.problem.get_problem_data(solver=cp.SCS)\n\n    def setup(self):\n        n = int(1e7)\n        c = np.arange(n)\n        x = cp.Variable(n)\n        objective = cp.Minimize(c @ x)\n        constraints = [0 <= x, x <= 1]\n        problem = cp.Problem(objective, constraints)\n        self.problem = problem",
        "min_run_count": 2,
        "name": "simple_LP_benchmarks.SimpleLPBenchmark.time_compile_problem",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "b81438c7919e9cb9394ca22fad039deba1325311fe54c0ae980452b93f34fe01",
        "warmup_time": -1
    },
    "simple_LP_benchmarks.SimpleScalarParametrizedLPBenchmark.time_compile_problem": {
        "code": "class SimpleScalarParametrizedLPBenchmark:\n    def time_compile_problem(self):\n        self.problem.get_problem_data(solver=cp.SCS)\n\n    def setup(self):\n        n = int(1e6)\n        p = cp.Parameter()\n        c = np.arange(n)\n        x = cp.Variable(n)\n        objective = cp.Minimize((p * c) @ x)\n        constraints = [0 <= x, x <= 1]\n        problem = cp.Problem(objective, constraints)\n        self.problem = problem",
        "min_run_count": 2,
        "name": "simple_LP_benchmarks.SimpleScalarParametrizedLPBenchmark.time_compile_problem",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "643deb6bc63211d7d322ac7ec9fe22c254ac6122afa51d53009157dbec777013",
        "warmup_time": -1
    },
    "simple_QP_benchmarks.LeastSquares.time_compile_problem": {
        "code": "class LeastSquares:\n    def time_compile_problem(self):\n        self.problem.get_problem_data(solver=cp.OSQP)\n\n    def setup(self):\n        m = 5000\n        n = 1000\n        np.random.seed(1)\n        A = np.random.randn(m, n)\n        b = np.random.randn(m)\n    \n        x = cp.Variable(n)\n        cost = cp.sum_squares(A @ x - b)\n        problem = cp.Problem(cp.Minimize(cost))\n        self.problem = problem",
        "min_run_count": 2,
        "name": "simple_QP_benchmarks.LeastSquares.time_compile_problem",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "a780c97f86faca1c0b75992ac06434a9cd0e17cbfd9b466cbd20060838729607",
        "warmup_time": -1
    },
    "simple_QP_benchmarks.ParametrizedQPBenchmark.time_compile_problem": {
        "code": "class ParametrizedQPBenchmark:\n    def time_compile_problem(self):\n        self.problem.get_problem_data(solver=cp.OSQP)\n\n    def setup(self):\n        m = 250\n        n = 100\n        np.random.seed(1)\n        A = cp.Parameter((m, n))\n        b = cp.Parameter((m,))\n    \n        x = cp.Variable(n)\n        objective = cp.Minimize(cp.sum_squares(A@x - b))\n        constraints = [0 <= x, x <= 1]\n        problem = cp.Problem(objective, constraints)\n        self.problem = problem",
        "min_run_count": 2,
        "name": "simple_QP_benchmarks.ParametrizedQPBenchmark.time_compile_problem",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "45f8e4bdac6459941852b20ed13605093901c6a5697e91a0c378aee939754277",
        "warmup_time": -1
    },
    "simple_QP_benchmarks.SimpleQPBenchmark.time_compile_problem": {
        "code": "class SimpleQPBenchmark:\n    def time_compile_problem(self):\n        self.problem.get_problem_data(solver=cp.OSQP)\n\n    def setup(self):\n        m = 2000\n        n = 400\n        p = 5\n        np.random.seed(1)\n        P = np.random.randn(n, n)\n        P = np.matmul(P.T, P)\n        q = np.random.randn(n)\n        G = np.random.randn(m, n)\n        h = np.matmul(G, np.random.randn(n))\n        A = np.random.randn(p, n)\n        b = np.random.randn(p)\n    \n        x = cp.Variable(n)\n        problem = cp.Problem(cp.Minimize((1/2)*cp.quad_form(x, P, assume_PSD=True) +\n                                         cp.matmul(q.T, x)),\n                       [cp.matmul(G, x) <= h,\n                       cp.matmul(A, x) == b])\n        self.problem = problem",
        "min_run_count": 2,
        "name": "simple_QP_benchmarks.SimpleQPBenchmark.time_compile_problem",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "ea0dd301c0877b3ceaf3230552bf2ea1d364065972d99f9c48392a3b5ce8248b",
        "warmup_time": -1
    },
    "slow_pruning_1668_benchmark.SlowPruningBenchmark.time_compile_problem": {
        "code": "class SlowPruningBenchmark:\n    def time_compile_problem(self):\n        self.problem.get_problem_data(solver=cp.SCS)\n\n    def setup(self):\n        \"\"\"Regression test for https://github.com/cvxpy/cvxpy/issues/1668\n    \n        Pruning matrices caused order-of-magnitude slow downs in compilation times.\n        \"\"\"\n        s = 2000\n        t = 10\n        x = np.linspace(-100.0, 100.0, s)\n        rows = 50\n        var = cp.Variable(shape=(rows, t))\n    \n        cost = cp.sum_squares(\n            var @ np.tile(np.array([x]), t).reshape((t, x.shape[0]))\n            - np.tile(x, rows).reshape((rows, s))\n        )\n        objective = cp.Minimize(cost)\n        problem = cp.Problem(objective)\n        self.problem = problem",
        "min_run_count": 2,
        "name": "slow_pruning_1668_benchmark.SlowPruningBenchmark.time_compile_problem",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "3844770ebf2a43f77aa8977342dd47622ffa2d45a39a6c5d93faf072035c21da",
        "warmup_time": -1
    },
    "svm_l1_regularization.SVMWithL1Regularization.time_compile_problem": {
        "code": "class SVMWithL1Regularization:\n    def time_compile_problem(self):\n        self.problem.get_problem_data(solver=cp.SCS)\n\n    def setup(self):\n        np.random.seed(1)\n        n = 500\n        m = 25000\n        DENSITY = 0.2\n        beta_true = np.random.randn(n, 1)\n        idxs = np.random.choice(range(n), int((1 - DENSITY) * n), replace=False)\n        for idx in idxs:\n            beta_true[idx] = 0\n    \n        offset = 0\n        sigma = 45\n        X = np.random.normal(0, 5, size=(m, n))\n        Y = np.sign(X.dot(beta_true) + offset + np.random.normal(0, sigma, size=(m, 1)))\n    \n        # Solve optimization problem\n        beta = cp.Variable((n, 1))\n        v = cp.Variable()\n        loss = cp.sum(cp.pos(1 - cp.multiply(Y, X @ beta - v)))\n        reg = cp.norm(beta, 1)\n        lambd = cp.Parameter(nonneg=True)\n        objective = cp.Minimize(loss / m + lambd * reg)\n        problem = cp.Problem(objective)\n        self.problem = problem",
        "min_run_count": 2,
        "name": "svm_l1_regularization.SVMWithL1Regularization.time_compile_problem",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "03d77ce97e937084e6f88faf3ac4cad3d9e26690ed9d022ea9190f1e15001ea5",
        "warmup_time": -1
    },
    "tv_inpainting.TvInpainting.time_compile_problem": {
        "code": "class TvInpainting:\n    def time_compile_problem(self):\n        self.problem.get_problem_data(solver=cp.SCS)\n\n    def setup(self):\n        Uorig = np.random.randn(512, 512, 3)\n        rows, cols, colors = Uorig.shape\n        known = np.zeros((rows, cols, colors))\n        for i in range(rows):\n            for j in range(cols):\n                if np.random.random() > 0.7:\n                    for k in range(colors):\n                        known[i, j, k] = 1\n    \n        Ucorr = known * Uorig  # This is elementwise mult on numpy arrays.\n        variables = []\n        constraints = []\n        for i in range(colors):\n                U = cp.Variable(shape=(rows, cols))\n                variables.append(U)\n                constraints.append(cp.multiply(\n                    known[:, :, i], U) == cp.multiply(\n                    known[:, :, i], Ucorr[:, :, i]))\n        problem = cp.Problem(cp.Minimize(cp.tv(*variables)), constraints)\n        self.problem = problem",
        "min_run_count": 2,
        "name": "tv_inpainting.TvInpainting.time_compile_problem",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "9e77ab42b03f5c2ebc54cdf3184e3fa6b04773212bbfdc734635987fd52f5678",
        "warmup_time": -1
    },
    "version": 2
}