{
    "cvar_benchmark.CVaRBenchmark.time_compile_problem": {
        "code": "class CVaRBenchmark:\n    def time_compile_problem(self):\n        self.problem.get_problem_data(solver=cp.SCS)\n\n    def setup(self):\n        # Replaced real data with random values\n        np.random.seed(0)\n        price_scenarios = np.random.randn(131072, 192)\n        forward_price_scenarios = np.random.randn(131072, 192)\n        asset_energy_limits = np.random.randn(192, 2)\n        bid_curve_prices = np.random.randn(192, 3)\n        cvar_prob = 0.95\n        cvar_kappa = 2.0\n    \n        num_scenarios, num_assets = price_scenarios.shape\n        num_energy_segments = bid_curve_prices.shape[1] + 1\n    \n        price_segments = np.sum(\n            forward_price_scenarios[:, :, None] > bid_curve_prices[None], axis=2\n        )\n        price_segments_flat = (\n            price_segments + np.arange(num_assets) * num_energy_segments\n        ).reshape(-1)\n        price_segments_sp = sp.coo_matrix(\n            (\n                np.ones(num_scenarios * num_assets),\n                (np.arange(num_scenarios * num_assets), price_segments_flat),\n            ),\n            shape=(num_scenarios * num_assets, num_assets * num_energy_segments),\n        )\n    \n        prices_flat = (price_scenarios - forward_price_scenarios).reshape(-1)\n        scenario_sum = sp.coo_matrix(\n            (\n                np.ones(num_scenarios * num_assets),\n                (\n                    np.repeat(np.arange(num_scenarios), num_assets),\n                    np.arange(num_scenarios * num_assets),\n                ),\n            )\n        )\n    \n        A = np.asarray((scenario_sum @ sp.diags(prices_flat) @ price_segments_sp).todense())\n        c = np.mean(A, axis=0)\n        gamma = 1.0 / (1.0 - cvar_prob) / num_scenarios\n        kappa = cvar_kappa\n        x_min = np.tile(asset_energy_limits[:, 0:1], (1, num_energy_segments)).reshape(-1)\n        x_max = np.tile(asset_energy_limits[:, 1:2], (1, num_energy_segments)).reshape(-1)\n    \n        alpha = cp.Variable()\n        x = cp.Variable(num_assets * num_energy_segments)\n    \n        problem = cp.Problem(\n            cp.Minimize(c.T @ x),\n            [\n                alpha + gamma * cp.sum(cp.pos(A @ x - alpha)) <= kappa,\n                x >= x_min,\n                x <= x_max,\n            ],\n        )\n    \n        self.problem = problem",
        "min_run_count": 2,
        "name": "cvar_benchmark.CVaRBenchmark.time_compile_problem",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 999,
        "type": "time",
        "unit": "seconds",
        "version": "2a130e57c07794b9a40b3e5a9a60e571c4fd23d7bc4db3d214200c409f06decc",
        "warmup_time": -1
    },
    "huber_regression.HuberRegression.time_compile_problem": {
        "code": "class HuberRegression:\n    def time_compile_problem(self):\n        self.problem.get_problem_data(solver=cp.SCS)\n\n    def setup(self):\n        np.random.seed(1)\n        n = 3000\n        p = 0.12\n        SAMPLES = int(1.5 * n)\n        beta_true = 5 * np.random.normal(size=(n, 1))\n        X = np.random.randn(n, SAMPLES)\n        v = np.random.normal(size=(SAMPLES, 1))\n    \n        # Generate the sign changes.\n        factor = 2 * np.random.binomial(1, 1 - p, size=(SAMPLES, 1)) - 1\n        Y = factor * X.T.dot(beta_true) + v\n        beta = cp.Variable((n, 1))\n        # Solve a huber regression problem\n        cost = cp.sum(cp.huber(X.T @ beta - Y, 1))\n        objective = cp.Minimize(cost)\n        problem = cp.Problem(objective)\n        self.problem = problem",
        "min_run_count": 2,
        "name": "huber_regression.HuberRegression.time_compile_problem",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "370ff6507bcc626b80bd3ca3731e4b1df2171a5b7510fb7e43a09572a8b2c71e",
        "warmup_time": -1
    },
    "optimal_advertising.OptimalAdvertising.time_compile_problem": {
        "code": "class OptimalAdvertising:\n    def time_compile_problem(self):\n        self.problem.get_problem_data(solver=cp.SCS)\n\n    def setup(self):\n        np.random.seed(1)\n        m = 250\n        n = 1000\n        SCALE = 10000\n        B = np.random.lognormal(mean=8, size=(m, 1)) + 10000\n        B = 1000 * np.round(B / 1000)\n    \n        P_ad = np.random.uniform(size=(m, 1))\n        P_time = np.random.uniform(size=(1, n))\n        P = P_ad.dot(P_time)\n    \n        T = np.sin(np.linspace(-2 * np.pi / 2, 2 * np.pi - 2 * np.pi / 2, n)) * SCALE\n        T += -np.min(T) + SCALE\n        c = np.random.uniform(size=(m,))\n        c *= 0.6 * T.sum() / c.sum()\n        c = 1000 * np.round(c / 1000)\n        R = np.array([np.random.lognormal(c.min() / c[i]) for i in range(m)])\n    \n        # Solve optimization problem\n        D = cp.Variable((m, n))\n        Si = [cp.minimum(R[i] * P[i, :] @ D[i, :].T, B[i]) for i in range(m)]\n        objective = cp.Maximize(cp.sum(Si))\n        constraints = [D >= 0, D.T @ np.ones(m) <= T, D @ np.ones(n) >= c]\n        problem = cp.Problem(objective, constraints)\n        self.problem = problem",
        "min_run_count": 2,
        "name": "optimal_advertising.OptimalAdvertising.time_compile_problem",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "c1a33d0f2763ff52fb848b520767be561f657e1ed9704dd7f263d252b8391fd5",
        "warmup_time": -1
    },
    "qp_1611_benchmark.QP1611Benchmark.time_compile_problem": {
        "code": "class QP1611Benchmark:\n    def time_compile_problem(self):\n        self.problem.get_problem_data(solver=cp.ECOS_BB)\n\n    def setup(self):\n        with open(QP1611Benchmark.filename, \"rb\") as f:\n            problem = pickle.load(f)\n        self.problem = problem",
        "min_run_count": 2,
        "name": "qp_1611_benchmark.QP1611Benchmark.time_compile_problem",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 999,
        "type": "time",
        "unit": "seconds",
        "version": "4f1e2751391e8545c90058b89a009be9a8748d009ad99b6f8a11222d314838cd",
        "warmup_time": -1
    },
    "sdp_segfault_1132_benchmark.SDPSegfault1132Benchmark.time_compile_problem": {
        "code": "class SDPSegfault1132Benchmark:\n    def time_compile_problem(self):\n        self.problem.get_problem_data(solver=cp.SCS)\n\n    def setup(self):\n        n = 100\n        alpha = 1\n        np.random.seed(0)\n        points = np.random.rand(5, n)\n        xtx = points.T @ points\n        xtxd = np.diag(xtx)\n        e = np.ones((n,))\n        D = np.outer(e, xtxd) - 2 * xtx + np.outer(xtxd, e)\n        # Construct W\n        W = np.ones((n, n))\n    \n        # Define V and e\n        n = D.shape[0]\n        x = -1 / (n + np.sqrt(n))\n        y = -1 / np.sqrt(n)\n        V = np.ones((n, n - 1))\n        V[0, :] *= y\n        V[1:, :] *= x\n        V[1:, :] += np.eye(n - 1)\n        e = np.ones((n, 1))\n    \n        # Solve optimization problem\n        G = cp.Variable((n - 1, n - 1), PSD=True)\n        A = cp.kron(e, cp.reshape(cp.diag(V @ G @ V.T), (1, n)))\n        B = cp.kron(e.T, cp.reshape(cp.diag(V @ G @ V.T), (n, 1)))\n        C = alpha * cp.norm(cp.multiply(W, A + B - 2 * V @ G @ V.T - D), p=\"fro\")\n        objective = cp.Maximize(cp.trace(G) - C)\n        problem = cp.Problem(objective, [])\n        self.problem = problem",
        "min_run_count": 2,
        "name": "sdp_segfault_1132_benchmark.SDPSegfault1132Benchmark.time_compile_problem",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 999,
        "type": "time",
        "unit": "seconds",
        "version": "ed808360d3230f364014822f855b979ad49e444e8bdeb093f06f2452c0c8deb5",
        "warmup_time": -1
    },
    "semidefinite_programming.SemidefiniteProgramming.time_compile_problem": {
        "code": "class SemidefiniteProgramming:\n    def time_compile_problem(self):\n        self.problem.get_problem_data(solver=cp.SCS)\n\n    def setup(self):\n        # Generate a random SDP.\n        n = 125\n        p = 75\n        np.random.seed(1)\n        C = np.random.randn(n, n)\n        A = []\n        b = []\n        for i in range(p):\n            A.append(np.random.randn(n, n))\n            b.append(np.random.randn())\n    \n        # Define and solve the CVXPY problem.\n        # Create a symmetric matrix variable.\n        X = cp.Variable((n, n), symmetric=True)\n        constraints = [X >> 0]\n        constraints += [cp.trace(A[i]@X) == b[i] for i in range(p)]\n        objective = cp.Minimize(cp.trace(C@X))\n        problem = cp.Problem(objective, constraints)\n        self.problem = problem",
        "min_run_count": 2,
        "name": "semidefinite_programming.SemidefiniteProgramming.time_compile_problem",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "7708d520cbcb2203c40cbc6c50278b5bbdd238f3ef571a4f70bbb2f1ead3abe7",
        "warmup_time": -1
    },
    "simple_LP_benchmarks.SimpleFullyParametrizedLPBenchmark.time_compile_problem": {
        "code": "class SimpleFullyParametrizedLPBenchmark:\n    def time_compile_problem(self):\n        self.problem.get_problem_data(solver=cp.SCS)\n\n    def setup(self):\n        n = int(1e4)\n        p = cp.Parameter(n)\n        x = cp.Variable(n)\n        objective = cp.Minimize(p @ x)\n        constraints = [0 <= x, x <= 1]\n        problem = cp.Problem(objective, constraints)\n        self.problem = problem",
        "min_run_count": 2,
        "name": "simple_LP_benchmarks.SimpleFullyParametrizedLPBenchmark.time_compile_problem",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "107c2224d8c77ed7a8e5e3a7ae3545dc2357739b7a7f37f02d5d8372fa10db09",
        "warmup_time": -1
    },
    "simple_LP_benchmarks.SimpleLPBenchmark.time_compile_problem": {
        "code": "class SimpleLPBenchmark:\n    def time_compile_problem(self):\n        self.problem.get_problem_data(solver=cp.SCS)\n\n    def setup(self):\n        n = int(1e7)\n        c = np.arange(n)\n        x = cp.Variable(n)\n        objective = cp.Minimize(c @ x)\n        constraints = [0 <= x, x <= 1]\n        problem = cp.Problem(objective, constraints)\n        self.problem = problem",
        "min_run_count": 2,
        "name": "simple_LP_benchmarks.SimpleLPBenchmark.time_compile_problem",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "b81438c7919e9cb9394ca22fad039deba1325311fe54c0ae980452b93f34fe01",
        "warmup_time": -1
    },
    "simple_LP_benchmarks.SimpleScalarParametrizedLPBenchmark.time_compile_problem": {
        "code": "class SimpleScalarParametrizedLPBenchmark:\n    def time_compile_problem(self):\n        self.problem.get_problem_data(solver=cp.SCS)\n\n    def setup(self):\n        n = int(1e6)\n        p = cp.Parameter()\n        c = np.arange(n)\n        x = cp.Variable(n)\n        objective = cp.Minimize((p * c) @ x)\n        constraints = [0 <= x, x <= 1]\n        problem = cp.Problem(objective, constraints)\n        self.problem = problem",
        "min_run_count": 2,
        "name": "simple_LP_benchmarks.SimpleScalarParametrizedLPBenchmark.time_compile_problem",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "643deb6bc63211d7d322ac7ec9fe22c254ac6122afa51d53009157dbec777013",
        "warmup_time": -1
    },
    "svm_l1_regularization.SVMWithL1Regularization.time_compile_problem": {
        "code": "class SVMWithL1Regularization:\n    def time_compile_problem(self):\n        self.problem.get_problem_data(solver=cp.SCS)\n\n    def setup(self):\n        np.random.seed(1)\n        n = 500\n        m = 25000\n        DENSITY = 0.2\n        beta_true = np.random.randn(n, 1)\n        idxs = np.random.choice(range(n), int((1 - DENSITY) * n), replace=False)\n        for idx in idxs:\n            beta_true[idx] = 0\n    \n        offset = 0\n        sigma = 45\n        X = np.random.normal(0, 5, size=(m, n))\n        Y = np.sign(X.dot(beta_true) + offset + np.random.normal(0, sigma, size=(m, 1)))\n    \n        # Solve optimization problem\n        beta = cp.Variable((n, 1))\n        v = cp.Variable()\n        loss = cp.sum(cp.pos(1 - cp.multiply(Y, X @ beta - v)))\n        reg = cp.norm(beta, 1)\n        lambd = cp.Parameter(nonneg=True)\n        objective = cp.Minimize(loss / m + lambd * reg)\n        problem = cp.Problem(objective)\n        self.problem = problem",
        "min_run_count": 2,
        "name": "svm_l1_regularization.SVMWithL1Regularization.time_compile_problem",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "03d77ce97e937084e6f88faf3ac4cad3d9e26690ed9d022ea9190f1e15001ea5",
        "warmup_time": -1
    },
    "version": 2
}